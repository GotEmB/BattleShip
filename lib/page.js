// Generated by IcedCoffeeScript 1.3.3d
var async, bindMouseDown, easeInOut, gotoGameOverMenu, hideFriendPlacingMenu, pleaseWait, roundTo1, setupCanvas, setupEvents, setupGame, setupPage, showDialog, showFriendPlacingMenu, socket, viewport, wdp, _ref;

easeInOut = function(x) {
  return Math.pow((Math.sin((x - 0.5) * Math.PI) + 1) * 0.5, 2);
};

roundTo1 = function(x) {
  return Math.round(x * 10) / 10;
};

async = function(a, b) {
  if (b != null) {
    return setTimeout(b, a);
  } else {
    return setTimeout(a, 0);
  }
};

bindMouseDown = function(sel, fn) {
  $(sel).bind("mousedown", fn);
  return $(sel).bind("touchstart", fn);
};

pleaseWait = {
  counter: 0,
  show: function() {
    pleaseWait.counter++;
    if (pleaseWait.counter > 0) return $("#pleaseWait").css("display", "block");
  },
  hide: function() {
    pleaseWait.counter--;
    if (pleaseWait.counter <= 0) return $("#pleaseWait").css("display", "none");
  }
};

wdp = (_ref = window.devicePixelRatio) != null ? _ref : 1;

viewport = document.querySelector("meta[name=viewport]");

viewport.setAttribute('content', "user-scalable=no, width=" + (320 * wdp) + ", height=" + (416 * wdp) + ", initial-scale=" + (1.0 / wdp) + ", maximum-scale=" + (1.0 / wdp));

socket = io.connect();

socket.on("connect", function() {
  return pleaseWait.hide();
});

socket.on("friendJoined", function() {
  return setupGame();
});

socket.on("friendDisconnected", function() {
  return gotoGameOverMenu("Your friend has left the game.");
});

window.onpopstate = function(e) {
  if (!(e.state != null)) {
    pleaseWait.show();
    socket.emit("resetAll", function() {
      return pleaseWait.hide();
    });
    async(550, function() {
      return setupCanvas({
        reset: true
      });
    });
    $("#menuView").addClass("enableTransitions");
    $("#mainMenu").removeClass("moveLeft");
    $("#mainMenu").removeClass("moveRight");
    $("#newMenu").addClass("moveRight");
    $("#joinMenu").addClass("moveRight");
    $("#gameOverMenu").addClass("moveLeft");
    $("#friendPlacingMenu").addClass("moveRight");
    $("#dialogMenu").addClass("moveRight");
    $("#menuViewContainer").addClass("enableTransitions");
    return $("#menuViewContainer").removeClass("moveDown");
  } else if (e.state.state === "newMenu") {
    $("#menuView").removeClass("enableTransitions");
    $("#mainMenu").addClass("moveLeft");
    $("#newMenu").removeClass("moveRight");
    return $("#joinMenu").addClass("moveRight");
  } else if (e.state.state === "joinMenu") {
    $("#menuView").removeClass("enableTransitions");
    $("#mainMenu").addClass("moveLeft");
    $("#newMenu").addClass("moveRight");
    return $("#joinMenu").removeClass("moveRight");
  }
};

setupPage = function() {
  var canvas;
  window.scrollTo(0, 1);
  $(document).bind("touchmove", function(e) {
    return e.preventDefault();
  });
  $(document).bind("touchstart", function(e) {
    if (!$(e.srcElement).hasClass("selectable")) return e.preventDefault();
  });
  $(document).bind("touchend", function(e) {
    if (!$(e.srcElement).hasClass("selectable")) return e.preventDefault();
  });
  pleaseWait.show();
  canvas = document.getElementById("canvas");
  canvas.setAttribute('width', "" + (320 * wdp));
  canvas.setAttribute('height', "" + (416 * wdp));
  paper.install(window);
  paper.setup(document.getElementById("canvas"));
  $("html, body").css("width", 320 * wdp);
  $("html, body").css("height", 416 * wdp);
  $("#menuView").css("-webkit-transform", "scale(" + wdp + ")");
  $("#menuView").css("display", "block");
  $("#pleaseWait div.container div.spinner").css("width", "" + (60 * wdp) + "px");
  $("#pleaseWait div.container div.spinner").css("height", "" + (60 * wdp) + "px");
  $("#pleaseWait div.container").css("padding", "" + (1.5 * wdp) + "em " + (1.5 * wdp) + "em " + (1.25 * wdp) + "em");
  $("#pleaseWait div.container").css("margin", "" + (153 * wdp) + "px " + (112 * wdp) + "px");
  return $("#gameId_Entry").focusout(function() {
    return window.scrollTo(0, 1);
  });
};

setupEvents = function() {
  bindMouseDown("#newGame_btn", function(e) {
    pleaseWait.show();
    return socket.emit("newGame", function(data) {
      if ((data != null) && data.status === "Game created") {
        $("#gameId").text(data.id);
        $("#menuView").addClass("enableTransitions");
        $("#mainMenu").addClass("moveLeft");
        $("#newMenu").removeClass("moveRight");
        history.pushState({
          state: "newMenu"
        }, "", "");
      } else {
        alert("Could not create game.");
        socket = io.connect();
      }
      return pleaseWait.hide();
    });
  });
  bindMouseDown("#joinGame_btn", function(e) {
    $("#gameId_entry").text("");
    $("#menuView").addClass("enableTransitions");
    $("#mainMenu").addClass("moveLeft");
    $("#joinMenu").removeClass("moveRight");
    return history.pushState({
      state: "joinMenu"
    }, "", "");
  });
  bindMouseDown("#enterGameId_btn", function(e) {
    pleaseWait.show();
    return socket.emit("joinGame", $("#gameId_entry").text(), function(data) {
      if ((data != null) && data.status === "Game joined") {
        setupGame();
      } else {
        alert((data != null) && (data.status != null) ? data.status : "Could not join game.");
      }
      return pleaseWait.hide();
    });
  });
  bindMouseDown("#gameOverOkay_btn", function(e) {
    return history.back();
  });
  return bindMouseDown("#dialogOkay_btn", function(e) {
    return $("#menuViewContainer").addClass("moveDown");
  });
};

setupGame = function() {
  async(550, function() {
    $("#menuView").removeClass("enableTransitions");
    $("#newMenu").addClass("moveRight");
    $("#joinMenu").addClass("moveRight");
    return $("#mainMenu").removeClass("moveLeft");
  });
  $("#menuViewContainer").addClass("enableTransitions");
  $("#menuViewContainer").addClass("moveDown");
  setupCanvas({
    setupShips: null
  });
  return history.replaceState({
    state: "inGame"
  }, "", "");
};

gotoGameOverMenu = function(msg, align) {
  $("#gameOver_msg").text(msg != null ? msg : "Something's happened.");
  $("#gameOver_msg").css("text-align", align != null ? align : "left");
  async(550, function() {
    return setupCanvas({
      reset: true
    });
  });
  $("#menuView").removeClass("enableTransitions");
  $("#mainMenu").removeClass("moveLeft");
  $("#mainMenu").addClass("moveRight");
  $("#newMenu").addClass("moveRight");
  $("#joinMenu").addClass("moveRight");
  $("#gameOverMenu").removeClass("moveLeft");
  $("#friendPlacingMenu").addClass("moveRight");
  $("#dialogMenu").addClass("moveRight");
  $("#menuViewContainer").addClass("enableTransitions");
  $("#menuViewContainer").removeClass("moveDown");
  return history.replaceState(null, "", "");
};

showFriendPlacingMenu = function() {
  $("#menuView").removeClass("enableTransitions");
  $("#mainMenu").addClass("moveLeft");
  $("#newMenu").addClass("moveRight");
  $("#joinMenu").addClass("moveRight");
  $("#gameOverMenu").addClass("moveLeft");
  $("#friendPlacingMenu").removeClass("moveRight");
  $("#dialogMenu").addClass("moveRight");
  $("#menuViewContainer").addClass("enableTransitions");
  return $("#menuViewContainer").removeClass("moveDown");
};

hideFriendPlacingMenu = function() {
  return $("#menuViewContainer").addClass("moveDown");
};

showDialog = function(msg) {
  $("#dialog_desc").text(msg != null ? msg : "I'm supposed to say somthing to you.");
  $("#menuView").removeClass("enableTransitions");
  $("#mainMenu").addClass("moveLeft");
  $("#newMenu").addClass("moveRight");
  $("#joinMenu").addClass("moveRight");
  $("#gameOverMenu").addClass("moveLeft");
  $("#friendPlacingMenu").addClass("moveRight");
  $("#dialogMenu").removeClass("moveRight");
  $("#menuViewContainer").addClass("enableTransitions");
  return $("#menuViewContainer").removeClass("moveDown");
};

setupCanvas = function(data) {
  var Game, canvasThis, inactiveTool, mainLayer, makeShip,
    _this = this;
  canvasThis = this;
  mainLayer = project.activeLayer;
  while (mainLayer.children.length > 0) {
    mainLayer.children[0].remove();
  }
  view.draw();
  if ((data.reset != null) && data.reset) {
    return $("#canvas").css("display", "none");
  }
  $("#canvas").css("display", "block");
  inactiveTool = new Tool();
  inactiveTool.activate();
  Game = (function() {

    function Game() {}

    Game.Board = (function() {

      function Board() {}

      Board.prototype.symbol = null;

      Board.prototype.placed = null;

      Board.prototype.back = null;

      Board.prototype.front = null;

      return Board;

    })();

    Game.Ships = (function() {

      function Ships() {}

      Ships.prototype.aircraftCarrier = null;

      Ships.prototype.battleShip = null;

      Ships.prototype.submarine = null;

      Ships.prototype.cruiser = null;

      Ships.prototype.destroyer = null;

      return Ships;

    })();

    Game.Player = (function() {

      function Player() {
        this.board = new Game.Board();
        this.ships = new Game.Ships();
      }

      return Player;

    })();

    Game.mine = new Game.Player();

    Game.yours = new Game.Player();

    return Game;

  })();
  (function() {
    var gridl, hline, hline_s, hlines, i, lstyle, vline, vline_s, vlines;
    lstyle = {
      strokeColor: "white",
      strokeWidth: 2 * wdp,
      strokeCap: "round"
    };
    vline = new Path();
    vline.style = lstyle;
    vline.add([0, 0]);
    vline.add([0, 300 * wdp]);
    vline_s = new Symbol(vline);
    vlines = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 10; i = ++_i) {
        _results.push(vline_s.place([i * 30 * wdp, 150 * wdp]));
      }
      return _results;
    })();
    hline = new Path();
    hline.style = lstyle;
    hline.add([0, 0]);
    hline.add([300 * wdp, 0]);
    hline_s = new Symbol(hline);
    hlines = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 10; i = ++_i) {
        _results.push(hline_s.place([150 * wdp, i * 30 * wdp]));
      }
      return _results;
    })();
    gridl = new Group(vlines);
    gridl.addChildren(hlines);
    return _this.gridl_s = new Symbol(gridl);
  })();
  (function() {
    var mine, mineGrid;
    Game.mine.board.back = new Layer();
    mainLayer.activate();
    mineGrid = gridl_s.place();
    Game.mine.board.front = new Layer();
    mainLayer.activate();
    mine = new Group([Game.mine.board.back, mineGrid, Game.mine.board.front]);
    return Game.mine.board.symbol = new Symbol(mine);
  })();
  (function() {
    var yours, yoursGrid;
    Game.yours.board.back = new Layer();
    mainLayer.activate();
    yoursGrid = gridl_s.place();
    Game.yours.board.front = new Layer();
    mainLayer.activate();
    yours = new Group([Game.yours.board.back, yoursGrid, Game.yours.board.front]);
    return Game.yours.board.symbol = new Symbol(yours);
  })();
  (function() {
    var arc, arrow, box, rotate;
    box = new Path.Rectangle([-14 * wdp, -14 * wdp], [28 * wdp, 28 * wdp]);
    box.style = {
      fillColor: "white",
      strokeWidth: 2 * wdp,
      strokeColor: "white",
      strokeCap: "square"
    };
    arc = new Path.Circle([0, 0], 6 * wdp);
    arc.style = {
      strokeColor: "black",
      strokeWidth: 3 * wdp,
      strokeCap: "round"
    };
    arc.closed = false;
    arc.rotate(-90);
    arrow = new Path([[1 * wdp, 0], [11 * wdp, 0], [6 * wdp, 5 * wdp]]);
    arrow.style = {
      fillColor: "black"
    };
    arrow.closePath();
    rotate = new Group([box, arc, arrow]);
    _this.rotate_s = new Symbol(rotate);
    _this.rotate_s.mouseDown = function() {
      box.fillColor = "black";
      arc.strokeColor = "white";
      return arrow.fillColor = "white";
    };
    return _this.rotate_s.mouseUp = function() {
      box.fillColor = "white";
      arc.strokeColor = "black";
      return arrow.fillColor = "black";
    };
  })();
  (function() {
    var arrow, box, next;
    box = new Path.Rectangle([-14 * wdp, -14 * wdp], [28 * wdp, 28 * wdp]);
    box.style = {
      fillColor: "white",
      strokeWidth: 2 * wdp,
      strokeColor: "white",
      strokeCap: "square"
    };
    arrow = new Path([[-4 * wdp, -8 * wdp], [6 * wdp, 0], [-4 * wdp, 8 * wdp]]);
    arrow.style = {
      fillColor: "black"
    };
    arrow.closePath();
    next = new Group([box, arrow]);
    _this.next_s = new Symbol(next);
    _this.next_s.mouseDown = function() {
      box.fillColor = "black";
      return arrow.fillColor = "white";
    };
    return _this.next_s.mouseUp = function() {
      box.fillColor = "white";
      return arrow.fillColor = "black";
    };
  })();
  makeShip = function(n) {
    var line, select, ship;
    line = new Path([[0, 0], [30 * (n - 1) * wdp, 0]]);
    line.style = {
      strokeColor: "white",
      strokeWidth: 10 * wdp,
      strokeCap: "round"
    };
    select = new Path([[0, 0], [30 * (n - 1) * wdp, 0]]);
    select.style = {
      strokeColor: "cyan",
      strokeWidth: 10 * wdp,
      strokeCap: "round"
    };
    select.strokeColor.alpha = 0.25;
    select.visible = false;
    ship = new Group([line, select]);
    ship.select = function() {
      return select.visible = true;
    };
    ship.deselect = function() {
      return select.visible = false;
    };
    ship.sunk = function() {
      return line.strokeColor = "red";
    };
    ship.unsunk = function() {
      return line.strokeColor = "white";
    };
    ship.boundary = {
      horizontal: new Rectangle({
        x: -(150 - 15 * n) * wdp,
        y: -135 * wdp,
        width: 2 * (150 - 15 * n) * wdp,
        height: 2 * 135 * wdp
      }),
      vertical: new Rectangle({
        x: -135 * wdp,
        y: -(150 - 15 * n) * wdp,
        width: 2 * 135 * wdp,
        height: 2 * (150 - 15 * n) * wdp
      })
    };
    ship.orientation = "horizontal";
    ship.size = n;
    ship.gridBounds = function() {
      return new Rectangle({
        x: roundTo1(ship.bounds.x - 15 * wdp),
        y: roundTo1(ship.bounds.y - 15 * wdp),
        width: roundTo1(ship.bounds.width + 30 * wdp),
        height: roundTo1(ship.bounds.height + 30 * wdp)
      });
    };
    return ship;
  };
  (function() {
    var player, ship, _i, _len, _ref1, _results;
    _ref1 = ["mine", "yours"];
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      player = _ref1[_i];
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (ship in Game.Ships.prototype) {
          Game[player].ships[ship] = makeShip((function() {
            switch (ship) {
              case "aircraftCarrier":
                return 5;
              case "battleShip":
                return 4;
              case "submarine":
                return 3;
              case "cruiser":
                return 3;
              case "destroyer":
                return 2;
            }
          })());
          Game[player].board.front.addChild(Game[player].ships[ship]);
          Game[player].ships[ship].visible = false;
          if (player === "mine") {
            _results1.push(Game[player].ships[ship].select());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  })();
  (function() {
    var redBack;
    redBack = new Path.Rectangle([0, 0], [30 * wdp, 30 * wdp]);
    redBack.style = {
      fillColor: "red"
    };
    redBack.fillColor.alpha = 0.5;
    return _this.redBack_s = new Symbol(redBack);
  })();
  (function() {
    _this.cursor = new Path.Rectangle([0, 0], [30 * wdp, 30 * wdp]);
    _this.cursor.style = {
      fillColor: "yellow"
    };
    _this.cursor.fillColor.alpha = 0.5;
    return _this.cursor.remove();
  })();
  (function() {
    var shot;
    shot = new Path.Circle([0, 0], 5 * wdp);
    shot.style = {
      fillColor: "white"
    };
    return _this.shot_s = new Symbol(shot);
  })();
  (function() {
    var redShot;
    redShot = new Path.Circle([0, 0], 5 * wdp);
    redShot.style = {
      fillColor: "red"
    };
    return _this.redShot_s = new Symbol(redShot);
  })();
  (function() {
    var flag;
    flag = new Path.Circle([0, 0], 2 * wdp);
    flag.style = {
      fillColor: "white"
    };
    return _this.flag_s = new Symbol(flag);
  })();
  (function() {
    var prevPos, selectedShip, shipMover, tool, validator;
    $("#setupShipsOverlay").css("display", "block");
    Game.mine.board.placed = Game.mine.board.symbol.place([160 * wdp, 160 * wdp]);
    _this.rotate_p = _this.rotate_s.place([261 * wdp, 335 * wdp]);
    _this.next_p = _this.next_s.place([296 * wdp, 335 * wdp]);
    selectedShip = Game.mine.ships.aircraftCarrier;
    selectedShip.visible = true;
    selectedShip.position = selectedShip.boundary[selectedShip.orientation].topLeft;
    prevPos = null;
    shipMover = (function() {

      function shipMover() {}

      shipMover.moveto = function(endPos) {
        var delta, startPos;
        startPos = shipMover.currentPos;
        shipMover.currentPos = endPos;
        delta = endPos.subtract(startPos);
        return view.onFrame = function(e) {
          if (e.time > 0.2) {
            view.onFrame = null;
            return selectedShip.position = endPos;
          } else {
            return selectedShip.position = startPos.add(delta.multiply(easeInOut(e.time / 0.2)));
          }
        };
      };

      shipMover.moveBy = function(delta) {
        if (!shipMover.currentPos.add(delta).isInside(selectedShip.boundary[selectedShip.orientation])) {
          return;
        }
        shipMover.moveto(shipMover.currentPos.add(delta));
        return prevPos = prevPos.add(delta);
      };

      shipMover.rotate = function() {
        var delta, endPos, newBoundary, startPos, transformMatrix;
        if (view.onFrame != null) return;
        validator.removeInvalidRedBacks();
        startPos = new Point(shipMover.currentPos);
        endPos = new Point(shipMover.currentPos);
        if (selectedShip.size % 2 === 0) {
          endPos = endPos.add(selectedShip.orientation === "horizontal" ? [15 * wdp, 15 * wdp] : [-15 * wdp, -15 * wdp]);
        }
        newBoundary = selectedShip.orientation === "horizontal" ? selectedShip.boundary.vertical : selectedShip.boundary.horizontal;
        if (endPos.x < newBoundary.left) endPos.x = newBoundary.left;
        if (endPos.x > newBoundary.right) endPos.x = newBoundary.right;
        if (endPos.y < newBoundary.top) endPos.y = newBoundary.top;
        if (endPos.y > newBoundary.bottom) endPos.y = newBoundary.bottom;
        shipMover.currentPos = endPos;
        delta = endPos.subtract(startPos);
        transformMatrix = new Matrix;
        selectedShip.orientation = selectedShip.orientation === "horizontal" ? "vertical" : "horizontal";
        return view.onFrame = function(e) {
          selectedShip.rotate(-transformMatrix.rotation);
          transformMatrix = new Matrix;
          if (e.time > 0.2) {
            transformMatrix.rotate(90);
            selectedShip.rotate(transformMatrix.rotation);
            selectedShip.position = endPos;
            return validator.addInvalidRedBacks();
          } else {
            transformMatrix.rotate(90 * easeInOut(e.time / 0.2));
            selectedShip.rotate(transformMatrix.rotation);
            selectedShip.position = startPos.add(delta.multiply(easeInOut(e.time / 0.2)));
            return startPos.add(delta.multiply(easeInOut(e.time / 0.2)));
          }
        };
      };

      return shipMover;

    }).call(_this);
    validator = (function() {

      function validator() {}

      validator.shipsAt = function(coordinates, ships) {
        var ret, ship, str, testPos, _i, _len, _ref1;
        ret = [];
        testPos = coordinates.multiply(30).subtract([135, 135]).multiply(wdp);
        _ref1 = ships != null ? ships : _.filter((function() {
          var _ref1, _results;
          _ref1 = Game.mine.ships;
          _results = [];
          for (str in _ref1) {
            ship = _ref1[str];
            _results.push(ship);
          }
          return _results;
        })(), function(ship) {
          return ship.visible;
        });
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          ship = _ref1[_i];
          if (testPos.isInside(ship.gridBounds())) ret.push(ship);
        }
        return ret;
      };

      validator.shipsOverlapping = function(ship) {
        var ret, ship1, str, _i, _len, _ref1;
        ret = [];
        _ref1 = _.filter((function() {
          var _ref1, _results;
          _ref1 = Game.mine.ships;
          _results = [];
          for (str in _ref1) {
            ship1 = _ref1[str];
            _results.push(ship1);
          }
          return _results;
        })(), function(ship1) {
          return ship1.visible;
        });
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          ship1 = _ref1[_i];
          if (ship === ship1) continue;
          if (ship.gridBounds().intersects(ship1.gridBounds())) ret.push(ship1);
        }
        return ret;
      };

      validator.shipsTouching = function(ship) {
        var intsec, ret, ship1, str, _i, _len, _ref1;
        ret = [];
        _ref1 = _.filter((function() {
          var _ref1, _results;
          _ref1 = Game.mine.ships;
          _results = [];
          for (str in _ref1) {
            ship1 = _ref1[str];
            _results.push(ship1);
          }
          return _results;
        })(), function(ship1) {
          return ship1.visible;
        });
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          ship1 = _ref1[_i];
          if (ship === ship1) continue;
          intsec = ship.gridBounds().intersect(ship1.gridBounds());
          if ((intsec.width === 0 && intsec.height > 0) || (intsec.height === 0 && intsec.width > 0)) {
            ret.push(ship1);
          }
        }
        return ret;
      };

      validator.invalidCoordinates = function() {
        var allCoordinates, allShips, i, invalidShips, j, overlappingShips, ship, str, touchingShips;
        allShips = _.filter((function() {
          var _ref1, _results;
          _ref1 = Game.mine.ships;
          _results = [];
          for (str in _ref1) {
            ship = _ref1[str];
            _results.push(ship);
          }
          return _results;
        })(), function(ship) {
          return ship.visible;
        });
        overlappingShips = _.union.apply(_, _.map(allShips, validator.shipsOverlapping));
        touchingShips = _.union.apply(_, _.map(allShips, validator.shipsTouching));
        invalidShips = _.union(overlappingShips, touchingShips);
        allCoordinates = _.flatten((function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i < 10; i = ++_i) {
            _results.push((function() {
              var _j, _results1;
              _results1 = [];
              for (j = _j = 0; _j < 10; j = ++_j) {
                _results1.push(new Point([i, j]));
              }
              return _results1;
            })());
          }
          return _results;
        })());
        return _.filter(allCoordinates, function(coordinates) {
          return validator.shipsAt(coordinates, invalidShips).length > 0;
        });
      };

      validator.removeInvalidRedBacks = function() {
        var redBack, _i, _len, _ref1, _results;
        _ref1 = _.clone(Game.mine.board.back.children);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          redBack = _ref1[_i];
          _results.push(redBack.remove());
        }
        return _results;
      };

      validator.addInvalidRedBacks = function() {
        var coordinates, redBack, _i, _j, _len, _len1, _ref1, _ref2;
        Game.mine.board.back.activate();
        _ref1 = validator.invalidCoordinates();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          coordinates = _ref1[_i];
          canvasThis.redBack_s.place(coordinates.multiply(30).subtract([135, 135]).multiply(wdp));
        }
        _ref2 = Game.mine.board.back.children;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          redBack = _ref2[_j];
          redBack.opacity = 0;
        }
        return view.onFrame = function(e) {
          var _k, _l, _len2, _len3, _ref3, _ref4, _results;
          if (e.time > 0.2) {
            _ref3 = Game.mine.board.back.children;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              redBack = _ref3[_k];
              redBack.opacity = 1;
            }
            return view.onFrame = null;
          } else {
            _ref4 = Game.mine.board.back.children;
            _results = [];
            for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
              redBack = _ref4[_l];
              _results.push(redBack.opacity = easeInOut(e.time / 0.2));
            }
            return _results;
          }
        };
      };

      return validator;

    }).call(_this);
    tool = new Tool();
    tool.maxDistance = 30 * wdp;
    shipMover.currentPos = selectedShip.position;
    tool.onMouseDown = function(e) {
      var layout, ship, str, _ref1, _ref2;
      prevPos = null;
      if (e.point.isInside(_this.rotate_p.bounds)) {
        shipMover.rotate();
        return _this.rotate_s.mouseDown();
      } else if (e.point.isInside(_this.next_p.bounds)) {
        if (!Game.mine.ships.destroyer.visible) {
          selectedShip.deselect();
          validator.removeInvalidRedBacks();
          if (!Game.mine.ships.battleShip.visible) {
            selectedShip = Game.mine.ships.battleShip;
          } else if (!Game.mine.ships.submarine.visible) {
            selectedShip = Game.mine.ships.submarine;
          } else if (!Game.mine.ships.cruiser.visible) {
            selectedShip = Game.mine.ships.cruiser;
          } else if (!Game.mine.ships.destroyer.visible) {
            selectedShip = Game.mine.ships.destroyer;
          }
          selectedShip.visible = true;
          selectedShip.position = selectedShip.boundary[selectedShip.orientation].topLeft;
          shipMover.currentPos = selectedShip.position;
          validator.addInvalidRedBacks();
        } else {
          if (Game.mine.board.back.children.length > 0) {
            return showDialog("Ships cannot touch or overlap each other.");
          }
          $("#setupShipsOverlay").css("display", "none");
          selectedShip.deselect();
          inactiveTool.activate();
          layout = {};
          _ref1 = Game.mine.ships;
          for (str in _ref1) {
            ship = _ref1[str];
            layout[str] = {
              coordinates: ship.bounds.topLeft.divide(wdp).add([135, 135]).divide(30),
              orientation: ship.orientation
            };
          }
          socket.emit("setShips", layout);
          showFriendPlacingMenu();
          _this.next_p.remove();
          _this.rotate_p.remove();
          Game.yours.board.placed = Game.yours.board.symbol.place([160 * wdp, 260 * wdp]);
          Game.yours.board.placed.scale(0.3, [160 * wdp, 410 * wdp]);
        }
        return _this.next_s.mouseDown();
      } else {
        _ref2 = Game.mine.ships;
        for (str in _ref2) {
          ship = _ref2[str];
          if (selectedShip === ship) continue;
          if (ship.visible && e.point.subtract(Game.mine.board.placed.position).isInside(ship.gridBounds())) {
            selectedShip.deselect();
            selectedShip = ship;
            selectedShip.select();
            shipMover.currentPos = selectedShip.position;
            return;
          }
        }
        validator.removeInvalidRedBacks();
        return prevPos = e.downPoint;
      }
    };
    tool.onMouseDrag = function(e) {
      var delta;
      if (prevPos === null) return;
      delta = e.point.subtract(prevPos);
      if (delta.x >= 30 * wdp) shipMover.moveBy([30 * wdp, 0]);
      if (delta.x <= -30 * wdp) shipMover.moveBy([-30 * wdp, 0]);
      if (delta.y >= 30 * wdp) shipMover.moveBy([0, 30 * wdp]);
      if (delta.y <= -30 * wdp) return shipMover.moveBy([0, -30 * wdp]);
    };
    tool.onMouseUp = function(e) {
      _this.rotate_s.mouseUp();
      _this.next_s.mouseUp();
      if (prevPos != null) {
        clearTimeout(_this.va);
        return _this.va = async(200, validator.addInvalidRedBacks);
      }
    };
    return tool.activate();
  })();
  (function() {
    var activateMine, activateYours, activeTool, cursorOn, gridHelper, myTurn, yourTurn;
    activateYours = function(e) {
      mainLayer.activate();
      if (e.time > 0.2) {
        view.onFrame = null;
        Game.mine.board.placed.remove();
        Game.mine.board.placed = Game.mine.board.symbol.place([160 * wdp, 160 * wdp]);
        Game.mine.board.placed.scale(0.3, [160 * wdp, 10 * wdp]);
        Game.yours.board.placed.remove();
        Game.yours.board.placed = Game.yours.board.symbol.place([160 * wdp, 260 * wdp]);
        return Game.yours.board.placed.scale(1, [160 * wdp, 410 * wdp]);
      } else {
        Game.mine.board.placed.remove();
        Game.mine.board.placed = Game.mine.board.symbol.place([160 * wdp, 160 * wdp]);
        Game.mine.board.placed.scale(1.0 - 0.7 * easeInOut(e.time / 0.2), [160 * wdp, 10 * wdp]);
        Game.yours.board.placed.remove();
        Game.yours.board.placed = Game.yours.board.symbol.place([160 * wdp, 260 * wdp]);
        return Game.yours.board.placed.scale(1.0 - 0.7 * easeInOut(1 - e.time / 0.2), [160 * wdp, 410 * wdp]);
      }
    };
    activateMine = function(e) {
      mainLayer.activate();
      if (e.time > 0.2) {
        view.onFrame = null;
        Game.yours.board.placed.remove();
        Game.yours.board.placed = Game.yours.board.symbol.place([160 * wdp, 260 * wdp]);
        Game.yours.board.placed.scale(0.3, [160 * wdp, 410 * wdp]);
        Game.mine.board.placed.remove();
        Game.mine.board.placed = Game.mine.board.symbol.place([160 * wdp, 160 * wdp]);
        return Game.mine.board.placed.scale(1, [160 * wdp, 10 * wdp]);
      } else {
        Game.yours.board.placed.remove();
        Game.yours.board.placed = Game.yours.board.symbol.place([160 * wdp, 260 * wdp]);
        Game.yours.board.placed.scale(1.0 - 0.7 * easeInOut(e.time / 0.2), [160 * wdp, 410 * wdp]);
        Game.mine.board.placed.remove();
        Game.mine.board.placed = Game.mine.board.symbol.place([160 * wdp, 160 * wdp]);
        return Game.mine.board.placed.scale(1.0 - 0.7 * easeInOut(1 - e.time / 0.2), [160 * wdp, 10 * wdp]);
      }
    };
    gridHelper = (function() {

      function gridHelper() {}

      gridHelper.coordinatesFromMouse = function(player, point) {
        var coord;
        coord = point.subtract(Game[player].board.placed.position).divide(wdp).add([135, 135]).divide(30);
        coord.x = Math.round(coord.x);
        coord.y = Math.round(coord.y);
        return coord;
      };

      gridHelper.gridPositionFromCoordinates = function(coordinates) {
        return coordinates.multiply(30).subtract([135, 135]).multiply(wdp);
      };

      gridHelper.gridBoundsFromCoordinates = function(coordinates) {
        var point;
        point = this.gridPositionFromCoordinates(coordinates);
        return new Rectangle({
          x: point.x - 15 * wdp,
          y: point.y - 15 * wdp,
          width: 30 * wdp,
          height: 30 * wdp
        });
      };

      return gridHelper;

    })();
    activeTool = new Tool();
    cursorOn = false;
    activeTool.onMouseDown = function(e) {
      var coordinates, flags, gridPosition;
      coordinates = gridHelper.coordinatesFromMouse("yours", e.point);
      gridPosition = gridHelper.gridPositionFromCoordinates(coordinates);
      if (_(Game.yours.board.back.children).any(function(x) {
        return (x.symbol != null) && x.symbol === this.redBack_s && e.point.subtract(Game.yours.board.placed.position).isInside(x.bounds);
      })) {
        return cursorOn = false;
      } else if (cursorOn && e.point.subtract(Game.yours.board.placed.position).isInside(_this.cursor.bounds)) {
        cursorOn = false;
        _this.cursor.remove();
        inactiveTool.activate();
        _.chain(Game.yours.board.front.children).filter(function(x) {
          return (x.symbol != null) && x.symbol === this.flag_s && gridPosition.isInside(x.bounds);
        }).each(function(x) {
          return x.remove();
        });
        Game.yours.board.back.activate();
        _this.redBack_s.place(gridPosition);
        return socket.emit("kaboom", coordinates, function(result) {
          var ship, shipCoords;
          switch (result.result) {
            case "hit":
              Game.yours.board.front.activate();
              this.shot_s.place(gridPosition);
              break;
            case "sunk":
              ship = Game.yours.ships[result.ship.type];
              if (result.ship.orientation === "vertical") ship.rotate(90);
              shipCoords = new Point(result.ship.coordinates);
              if (result.ship.orientation === "horizontal") {
                shipCoords.x += ship.size / 2;
              } else {
                shipCoords.y += ship.size / 2;
              }
              ship.position = gridHelper.gridPositionFromCoordinates(shipCoords);
              ship.visible = true;
              break;
            case "gameOver":
              showGameOverMenu("You Won! :D", "center");
          }
          if (result.result !== "gameOver") return async(1000, yourTurn);
        });
      } else {
        cursorOn = true;
        Game.yours.board.back.addChild(_this.cursor);
        _this.cursor.position = gridPosition;
        flags = _(Game.yours.board.front.children).filter(function(x) {
          return (x.symbol != null) && x.symbol === this.flag_s && gridPosition.isInside(x.bounds);
        });
        if (flags.length === 0) {
          Game.yours.board.back.activate();
          _this.flag_s.place(gridPosition);
        } else {
          _(flags).each(function(x) {
            return x.remove();
          });
        }
        return view.onFrame = function(e) {
          if (e.time > 1) {
            view.onFrame = null;
            cursorOn = false;
            return _this.cursor.remove();
          } else {
            return _this.cursor.opacity = 1 - easeInOut(e.time);
          }
        };
      }
    };
    myTurn = function() {
      hideFriendPlacingMenu();
      view.onFrame = activateYours;
      return activeTool.activate();
    };
    yourTurn = function() {
      hideFriendPlacingMenu();
      view.onFrame = activateMine;
      return inactiveTool.activate();
    };
    socket.on("yourTurn", myTurn);
    socket.on("theirTurn", yourTurn);
    return socket.on("shotAt", function(data) {
      var gridPosition;
      Game.mine.board.back.activate();
      gridPosition = gridHelper.gridPositionFromCoordinates(data.shotAt);
      this.redBack_s.place(gridPosition);
      switch (data.result) {
        case "hit":
          Game.mine.board.front.activate();
          this.redShot_s.place(gridPosition);
          break;
        case "sunk":
          Game.mine.ships[data.ship.type].sunk();
          break;
        case "gameOver":
          showGameOverMenu("You Lost! :(", "center");
      }
      if (data.result !== "gameOver") return async(1000, myTurn);
    });
  })();
  return view.draw();
};

$(document).ready(function() {
  setupPage();
  return setupEvents();
});